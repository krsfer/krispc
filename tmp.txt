(async function () {
    'use strict';

    let pointA = null;

    let contact_position = null;

    let contact_name = null;
    let contact_route = null;

    let map = null; // Define map as a global variable

    let simPoint = null; // Declare simPoint as a global variable

    window.simPoint = null;

    let simulationActive = false; // Declare simulationActive as a global variable

    let contacts_markers = [];
    let contacts_markers_dict = {};

    let monitorTextbox = null;

    let geoTextbox = null;

    let mapSimulation = null;

    let isGeolocating = false;

    let geo = [];

    let i = 0; // Define i in an outer scope
    let t = 0; // Define t in an outer scope

    let startPoint = null;
    let endPoint = null;

    const speed = 0.05; // Define speed in an outer scope (adjust this value to change the speed of the animation)

    let coordinates = null; // Define coordinates in an outer scope

    let simMar = null; // Define simMar in an outer scope

    window.backgroundColor = 'rgba(255, 255, 255, 0.3)';
    const line_width = 12;

    const bb = document.getElementById('blue_ball').value; // eg. /static/watapp/img/blue_ball.png
    const gb = document.getElementById('green_ball').value;

    const response = await fetch('contacts_json');
    const contacts_lst = await response.json();

    const getAccessToken = async (token_id) => {
        const response = await fetch(token_id);
        const data = await response.json();
        return data.token;
    };

    window.mapbox_token = await getAccessToken('mapbox_token');
    window.googlemaps_token = await getAccessToken('googlemaps_token');

    const selectedStyle = localStorage.getItem('selectedMapStyle') || 'mapbox://styles/mapbox/dark-v9';

    function interpolate(pointA, pointB, numSegments) {
        const dx = (pointB[0] - pointA[0]) / numSegments;
        const dy = (pointB[1] - pointA[1]) / numSegments;
        const points = [];
        for (let i = 0; i <= numSegments; i++) {
            const x = pointA[0] + dx * i;
            const y = pointA[1] + dy * i;
            points.push([x, y]);
        }
        return points;
    }

    function addmarker(map, lnglat, name, address, el) {
        const marker = contacts_markers.find((marker) => {
            return marker.getLngLat().lng === lngLat[0] && marker.getLngLat().lat === lngLat[1];
        }) || new mapboxgl.Marker(el)
            .setLngLat(lngLat)
            .setPopup(
                new mapboxgl.Popup()
                    .setHTML(`<h3>${name}</h3><p>${address}</p>`),
            )
            .addTo(map);

        marker.getElement().style.visibility = "visible";

        marker.getPopup().options.closeButton = false;

        marker.getElement().style.zIndex = 1;

        marker.getElement().style.cursor = 'pointer';

        contacts_markers.push(marker);

        marker.getElement().addEventListener('click', function () {

            const key = `${lngLat[0].toFixed(2)}_${lngLat[1].toFixed(2)}`;

            const value = contacts_markers_dict[key];

            contact_name = value; // Update contact_name
            contact_position = lngLat; // Update contact_position

            if (isGeolocating) {
                resetRoutesExceptSelected(map, contact_name);

                getDirections([geo[0], geo[1]], contact_position)
                    .then(({route, distance, durée, eta, address}) => {

                        if (!monitorTextbox)
                            monitorTextbox = new Monitor_textbox(map, window.backgroundColor);

                        displayUpdates(monitorTextbox, distance, durée, eta, address);

                        setTimeout(() => {
                            marker.getPopup().getElement().classList.add("fade-out");
                        }, 500);
                        marker.getPopup().getElement().style.zIndex = 0;

                        const routeName = contacts_markers_dict[`${contact_position[0].toFixed(2)}_${contact_position[1].toFixed(2)}`];
                        map.getSource(routeName).setData(route.geometry);
                        contact_route = route.geometry.coordinates;
                    });
            } else {
                setTimeout(() => {
                    marker.getPopup().getElement().classList.add("fade-out");
                }, 500);
            }
        });

    }

    function addRouteLayer(map, routeName, route, destination) {
        const routeId = routeName; // Identifier for the route layer and source

        const routeFeature = {
            'type': 'Feature',
            'properties': {},
            'geometry': {
                'type': 'LineString',
                'coordinates': route
            }
        };

        if (!map.getSource(routeId)) {
            map.addSource(routeId, {
                'type': 'geojson',
                'data': routeFeature
            });
        }

        if (!map.getLayer(routeId)) {
            map.addLayer({
                'id': routeId,
                'type': 'line',
                'source': routeId,
                'layout': {},
                'paint': {
                    "line-color": "rgb(255,0,0)",
                    "line-width": 8,
                },
            });

            map.on('mouseenter', routeId, function () {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', routeId, function () {
                map.getCanvas().style.cursor = '';
            });

            map.on('click', routeId, function (e) {
                console.log('Route line clicked:', e);
                map.panTo(destination);
            });
        }
    }

    function createRouteName(contact_name) {
        return contact_name.replace(/\s/g, "_") + "_route";
    }

    function updateContactsAndWarnOnError(name, lngLat, errorMessage, contact) {
        updateContactsJson(name, lngLat).catch((error) => {
            console.warn(`${errorMessage} > ${error.message} <`, contact);
        });
    }

    function addContactMarkers(map) {
        contacts_lst.contacts.forEach((contact) => {
            const routeName = createRouteName(contact.name);

            const el = document.createElement('div');
            el.className = 'marker';

            let lngLat;
            if (contact.coords.length !== 0) {
                lngLat = contact.coords;
                addMarker(map, lngLat, contact.name, contact.address, el);
            } else {
                getLngLatFromAddress(contact.address)
                    .then((lngLat) => {
                        addMarker(map, lngLat, contact.name, contact.address, el);
                        updateContactsAndWarnOnError(contact.name, lngLat, '!!An error occurred using nominatim:', contact);
                    })
                    .catch((error) => {
                        console.warn('!!An error occurred using nominatim: >' + error.message + '<', contact);
                        getLngLatFromAddress_mapbox(contact.address)
                            .then((lngLat) => {
                                addMarker(map, lngLat, contact.name, contact.address, el);
                                updateContactsAndWarnOnError(contact.name, lngLat, '!!An error occurred using mapbox:', contact);
                            });
                    });
            }

            contacts_markers_dict[`${lngLat[0].toFixed(2)}_${lngLat[1].toFixed(2)}`] = routeName;
        });

    }

    function addRouteLayers(map) {
        contacts_lst.contacts.forEach((contact) => {
            const routeName = createRouteName(contact.name);

            const startPoint = contact.coords;
            const endPoint = [startPoint[0], startPoint[1] + 0.045045045]; // 5 km to the north
            const numSegments = 50;

            const points = [];

            if (isGeolocating) {
                addRouteLayer(map, routeName, contact_route, startPoint)
            } else
                addRouteLayer(map, routeName, points, startPoint);
        });
    }

    function resetRoutesExceptSelected(map, selectedRouteName) {
        const layers = map.getStyle().layers;

        layers.forEach((layer) => {
            if (layer.id.endsWith('_route') && layer.id !== selectedRouteName) {
                map.getSource(layer.id).setData({
                    'type': 'FeatureCollection',
                    'features': []
                });
            }
        });
    }

    function addMapStyleSelector(map) {
        const select = document.createElement('select');
        select.style.position = 'absolute';
        select.style.top = '10px';

        select.style.right = '50px';

        select.style.backgroundColor = backgroundColor; // 60% transparent background
        select.style.textAlign = 'center';
        select.style.borderRadius = '10px';
        select.style.border = '1px solid lightgrey';
        select.style.zIndex = '10';

        const mapStyles = [
            {name: 'Dark', style: 'mapbox://styles/mapbox/dark-v9'},
            {name: 'Light', style: 'mapbox://styles/mapbox/light-v9'},
            {name: 'Streets', style: 'mapbox://styles/mapbox/streets-v11'},
            {name: 'Outdoors', style: 'mapbox://styles/mapbox/outdoors-v11'},
            {name: 'Satellite', style: 'mapbox://styles/mapbox/satellite-v9'}
        ];

        for (const mapStyle of mapStyles) {
            const option = document.createElement('option');
            option.value = mapStyle.style;
            option.text = mapStyle.name;
            select.appendChild(option);
        }

        select.value = selectedStyle;

        map.getContainer().appendChild(select);

        select.addEventListener('change', function () {
            map.setStyle(this.value);

            localStorage.setItem('selectedMapStyle', this.value);
        });
    }

    function removeAllPopups() {
        contacts_markers.forEach((marker) => {
            if (marker.getPopup().isOpen()) {
                marker.togglePopup();
            }
        });
    }

    function initializeMap() {
        mapboxgl.accessToken = window.mapbox_token;

        const map = new mapboxgl.Map({
            container: 'map', // Specify the container ID
            style: selectedStyle, // Specify the initial map style
            center: [7.008715192368488, 43.64163999646119], // Valbonne 43.64163999646119, 7.008715192368488
            zoom: 11 // Set the initial zoom level
        });

        map.on('load', function () {
            addContactMarkers(map); // Add the contact markers when the map initially loads
            addRouteLayers(map); // Add the route layer when the map initially loads

        });

        map.on('style.load', function () {
            addContactMarkers(map); // Add the contact markers when the map initially loads
            addRouteLayers(map); // Re-add the route layer every time the map style changes and is fully loaded
        });

        map.addControl(new mapboxgl.NavigationControl());

        let attributionControl = null;

        for (const control of map._controls) {
            if (control instanceof mapboxgl.AttributionControl) {
                attributionControl = control;
                break;
            }
        }
        if (attributionControl) {
            map.removeControl(attributionControl);
        } else {
            console.log("Attribution control not found.");
        }

        map.attrControl = new mapboxgl.AttributionControl({
            compact: true,
            customAttribution: "Made with ❤ by <a href='mailto://archer.chris@gmail.com'>C. Archer.</a> D’après une idée" +
                " de P. Ricaud",
        });
        map.addControl(map.attrControl, "bottom-right");

        map.on('click', (e) => {
            const END = Object.keys(e.lngLat).map((key) => e.lngLat[key]);
            const coordsTxt = JSON.stringify(END);
        });

        map.on('mousedown', (e) => {
            i = 0;
            t = 0;
            const timer = setInterval(() => {
                i++;
                if (i === 10) {
                    console.log("long press");
                    clearInterval(timer);
                    const END = Object.keys(e.lngLat).map((key) => e.lngLat[key]);
                    const coordsTxt = JSON.stringify(END);
                    navigator.clipboard.writeText(coordsTxt).then(r => console.log());
                    console.log("Map longpressed at:", coordsTxt);
                }
            }, 100);
            map.on('mouseup', () => {
                clearInterval(timer);
            });

            map.on('move', function () {
                removeAllPopups();
            });
        });

        addMapStyleSelector(map);

        const currentZoom = map.getZoom();

        const geolocate = new mapboxgl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true
            },
            trackUserLocation: true,
            showAccuracyCircle: true,
            showUserLocation: true,
        });
        map.addControl(geolocate, 'top-right');

        class ContactsControl {
            constructor(map, backgroundColor) {
                this.contact_list_toggle_btn = document.createElement("button");
                this.contact_list_toggle_btn.innerText = "Contacts";
                this.contact_list_toggle_btn.classList.add("contacts-button");
                this.contact_list_toggle_btn.style.position = "absolute";
                this.contact_list_toggle_btn.style.top = "10px";
                this.contact_list_toggle_btn.style.left = "10px";
                this.contact_list_toggle_btn.style.borderRadius = "10px";
                this.contact_list_toggle_btn.style.border = "1px solid grey";
                this.contact_list_toggle_btn.style.backgroundColor = backgroundColor;
                this.contact_list_toggle_btn.style.visibility = "visible";

                this.contact_list_toggle_btn.addEventListener("click", () => {
                    this.toggleVisibility()
                });

                map.getContainer().appendChild(this.contact_list_toggle_btn);
            }

            toggleVisibility() {
                console.log("toggleVisibility");

                if (contacts_markers.length === 0) {
                    console.error("markers array is empty");
                } else {
                    contacts_markers.forEach((marker) => {
                        console.log("marker.getElement().id", marker.getElement().id);
                        const visibility = marker.getElement().style.visibility;

                        console.log("visibility before", marker.getElement().style.visibility)

                        if (visibility === "visible") {
                            marker.getElement().style.visibility = "hidden";
                        } else {
                            marker.getElement().style.visibility = "visible";
                        }

                        console.log("visibility after", marker.getElement().style.visibility)
                    });

                }
            }
        }

        let contactsControl = new ContactsControl(map, window.backgroundColor);

        geolocate.on('trackuserlocationend', function () {
            const geolocateButton = document.getElementsByClassName('mapboxgl-ctrl-geolocate')[0];

            const classList = geolocateButton.classList;

            if (!classList.contains('mapboxgl-ctrl-geolocate-active') && !classList.contains('mapboxgl-ctrl-geolocate-background')) {
                isGeolocating = false;
                console.log("isGeolocating set to false", isGeolocating);
            }
        });

        let geo_travelled = []; // Declare geo_travelled as a global variable
        let geo_textbox = null;
        let geo_times = 0; // Declare geo_times as a global variable

        geolocate.on('geolocate', function (e) {
            isGeolocating = true;

            geo = [e.coords.longitude, e.coords.latitude];

            geo_times = geo_times + 1;

            let speed = 'no speed';
            if (e.coords.speed)
                speed = toString(convertMetersPerSecondToKilometersPerHour(e.coords.speed)) + ' km/h'

            let heading = "no heading";
            if (e.coords.heading)
                heading = toString(e.coords.heading) + '°'

            let accuracy = 'no accuracy';
            if (e.coords.accuracy)
                accuracy = e.coords.accuracy + ' m'

            if (!geo_textbox)
                geo_textbox = new Geo_textbox(map, window.backgroundColor);

            if (geo_textbox && speed > 0) {
                setTimeout(() => {
                    geo_textbox.geoTextbox.classList.add("fade-out");
                }, 500)
            } else {
                console.log("geo_textbox does not exist");
            }

            geo_textbox.geoTextbox.innerText = `geo_times: ${geo_times}
                speed: ${speed}
                heading: ${heading}
                accuracy: ${accuracy}`;

            if (contact_position) {
                resetRoutesExceptSelected(map, contact_name);

                getDirections([e.coords.longitude, e.coords.latitude], contact_position)
                    .then(({route, distance, durée, eta, address}) => {

                        if (!monitorTextbox)
                            monitorTextbox = new Monitor_textbox(map, window.backgroundColor);

                        displayUpdates(monitorTextbox, distance, durée, eta, address);

                        const routeName = contacts_markers_dict[`${contact_position[0].toFixed(2)}_${contact_position[1].toFixed(2)}`];
                        map.getSource(routeName).setData(route.geometry);
                        contact_route = route.geometry.coordinates;
                    });
            }
        });
    }

    initializeMap(); // Call the function to initialize the map

    class Monitor_textbox {
        constructor(map, backgroundColor) {
            this.monitorTextbox = document.createElement("div");
            this.monitorTextbox.classList.add("monitor-textbox");
            this.monitorTextbox.innerText = "";
            this.monitorTextbox.style.backgroundColor = backgroundColor;
            this.monitorTextbox.style.border = "1px solid";
            this.monitorTextbox.style.borderColor = "rgba(194, 181, 181)";
            this.monitorTextbox.style.borderRadius = "10px";
            this.monitorTextbox.style.bottom = "5px";
            this.monitorTextbox.style.textShadow = "1px 1px 1px #ccc";
            this.monitorTextbox.style.color = "rgb(0,0,0)";
            this.monitorTextbox.style.fontSize = '20px';
            this.monitorTextbox.style.lineHeight = "0.9";
            this.monitorTextbox.style.overflow = "auto";
            this.monitorTextbox.style.padding = "10px";
            this.monitorTextbox.style.position = "absolute";
            this.monitorTextbox.style.textAlign = "center";
            this.monitorTextbox.style.right = "5px";
            this.monitorTextbox.style.zIndex = "1";

            map.getContainer().appendChild(this.monitorTextbox);
        }
    }

    class Geo_textbox {
        constructor(map, backgroundColor) {
            this.geoTextbox = document.createElement("div");
            this.geoTextbox.classList.add("geo-textbox");
            this.geoTextbox.innerText = "";
            this.geoTextbox.style.backgroundColor = backgroundColor;
            this.geoTextbox.style.border = "1px solid";
            this.geoTextbox.style.borderColor = "rgba(194, 181, 181)";
            this.geoTextbox.style.borderRadius = "10px";
            this.geoTextbox.style.top = "5px"; // Changed from "bottom: 5px"
            this.geoTextbox.style.textShadow = "1px 1px 1px #ccc";
            this.geoTextbox.style.color = "rgb(0,0,0)";
            this.geoTextbox.style.fontSize = '20px';
            this.geoTextbox.style.lineHeight = "0.9";
            this.geoTextbox.style.overflow = "auto";
            this.geoTextbox.style.padding = "10px";
            this.geoTextbox.style.position = "absolute";
            this.geoTextbox.style.textAlign = "center";
            this.geoTextbox.style.left = "5px";
            this.geoTextbox.style.zIndex = "1";

            map.getContainer().appendChild(this.geoTextbox);
        }
    }

    class ContactsControl {
        constructor(map, backgroundColor) {
            this.contact_list_toggle_btn = document.createElement("button");
            this.contact_list_toggle_btn.innerText = "Contacts";
            this.contact_list_toggle_btn.classList.add("contacts-button");
            this.contact_list_toggle_btn.style.position = "absolute";
            this.contact_list_toggle_btn.style.top = "10px";
            this.contact_list_toggle_btn.style.left = "10px";
            this.contact_list_toggle_btn.style.borderRadius = "10px";
            this.contact_list_toggle_btn.style.border = "1px solid grey";
            this.contact_list_toggle_btn.style.backgroundColor = backgroundColor;
            this.contact_list_toggle_btn.style.visibility = "visible";

            this.contact_list_toggle_btn.addEventListener("click", () => {
                this.toggleVisibility()
            });

            map.getContainer().appendChild(this.contact_list_toggle_btn);
        }

        toggleVisibility() {
            console.log("toggleVisibility");

            if (contacts_markers.length === 0) {
                console.error("markers array is empty");
            } else {
                let anyVisible = true;
                contacts_markers.forEach((marker) => {
                    marker._element.hidden = !marker._element.hidden;
                    anyVisible = marker._element.hidden;
                });

                this.contact_list_toggle_btn.style.backgroundColor = anyVisible ? 'grey' : backgroundColor;
            }
        }
    }
})
();
