import { jsPDF } from 'jspdf';
import { PatternState, GridCell } from '@/types/pattern';
import { PatternGenerator } from './pattern-generator';

export class PatternPrinter {
  /**
   * Generates a high-quality A4 PDF of the pattern
   */
  static async generatePDF(
    pattern: PatternState,
    grid: GridCell[][],
    filename: string = 'emoty-pattern.pdf'
  ): Promise<void> {
    // 1. Setup PDF
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;

    // 2. Add Header
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(24);
    doc.setTextColor(51, 51, 51); // Dark grey
    
    const title = pattern.name || 'Untitled Pattern';
    const titleWidth = doc.getTextWidth(title);
    doc.text(title, (pageWidth - titleWidth) / 2, margin + 10);

    // 3. Add Subheader (Date/Sequence)
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.setTextColor(100, 100, 100);

    const dateStr = pattern.createdAt 
      ? new Date(pattern.createdAt).toLocaleDateString() 
      : new Date().toLocaleDateString();
    
    const subtitle = `Created on ${dateStr}`;
    const subtitleWidth = doc.getTextWidth(subtitle);
    doc.text(subtitle, (pageWidth - subtitleWidth) / 2, margin + 20);

    // 4. Render Pattern to Image
    // We need to create a temporary canvas to render the pattern at high resolution
    const imageUrl = await this.renderPatternToImage(grid);
    
    if (imageUrl) {
      // Calculate image dimensions to fit nicely
      const maxWidth = pageWidth - (margin * 2);
      const maxHeight = pageHeight - 100; // Leave room for header/footer
      const imgSize = Math.min(maxWidth, maxHeight);
      
      const x = (pageWidth - imgSize) / 2;
      const y = margin + 30;

      doc.addImage(imageUrl, 'PNG', x, y, imgSize, imgSize);
    }

    // 5. Add Sequence Text
    const sequenceStr = pattern.sequence.join(' ');
    doc.setFontSize(14);
    doc.setTextColor(0, 0, 0);
    // Split text if too long
    const splitSequence = doc.splitTextToSize(sequenceStr, pageWidth - (margin * 2));
    const seqY = margin + 30 + Math.min(pageWidth - (margin * 2), pageHeight - 100) + 15;
    
    // Centered text
    doc.text(splitSequence, pageWidth / 2, seqY, { align: 'center' });

    // 6. Footer
    doc.setFontSize(10);
    doc.setTextColor(128, 128, 128);
    const footerText = 'Generated by Emoty - The Emoji Pattern Creator';
    doc.text(footerText, pageWidth / 2, pageHeight - 10, { align: 'center' });

    // 7. Save
    doc.save(filename);
  }

  /**
   * Renders the grid to a high-res PNG data URL
   */
  private static renderPatternToImage(grid: GridCell[][]): Promise<string> {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        resolve('');
        return;
      }

      // High resolution
      const size = 1200;
      const padding = 40;
      const cellSize = (size - (padding * 2)) / grid.length;

      canvas.width = size;
      canvas.height = size;

      // Background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, size, size);

      // Draw Grid
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${cellSize * 0.7}px Arial`; // Use a standard font that supports emojis if possible

      for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[row].length; col++) {
          const cell = grid[row][col];
          if (cell.emoji) {
            const x = padding + (col * cellSize) + (cellSize / 2);
            const y = padding + (row * cellSize) + (cellSize / 2);
            
            ctx.fillStyle = '#000000';
            ctx.fillText(cell.emoji, x, y);
          }
        }
      }

      resolve(canvas.toDataURL('image/png'));
    });
  }
}
